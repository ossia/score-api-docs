<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>score: score::gfx Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="http://ossia.io">score </a>
                </div>
                <ul class="nav navbar-nav">
                  <li class="active"><a href="index.html">Home</a></li>
                  <li><a href="classes.html">Classes</a></li>
                  <li><a href="namespaces.html">Namespaces</a></li>
                  <li><a href="files.html">Files</a></li>
                </ul>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacescore_1_1gfx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">score::gfx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Graphics rendering pipeline for ossia score.  
<a href="namespacescore_1_1gfx.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graphics rendering pipeline for ossia score. </p>
<p>This namespace provides a rendering pipeline for GPU visuals, by the way of a rendering graph. The implementation uses the Qt RHI:</p>
<p><a href="https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d">https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d</a></p>
<p>It is mainly designed for rendering a succession of visual effects, not rendering arbitrary 3D. Shaders are written in the usual glslang -&gt; spirv-cross fashion, with GLSL #version 450. They are then translated automatically to SPIRV, Metal, GLSL or D3D11 shaders.</p>
<p>The overall design is as follows :</p>
<ul>
<li>Elements to render are represented as nodes to a graph: <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a></li>
<li>Input ports are the uniforms and input textures &amp; audio data.</li>
<li>Output ports generally are just the texture we are rendering to.</li>
<li><a class="el" href="structscore_1_1gfx_1_1_graph.html" title="Represents a graph of renderers.">score::gfx::Graph</a> contains all the nodes, and relationships between these nodes.</li>
<li>For each output sink (a window surface, an NDI or Spout output...), a <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">score::gfx::RenderList</a> is created. It contains all the nodes to render for a given output.</li>
<li>For each <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a>, the <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">score::gfx::RenderList</a> creates a <a class="el" href="classscore_1_1gfx_1_1_node_renderer.html" title="Renderer for a given node.">score::gfx::NodeRenderer</a> which contains the actual GPU resource handles for the sink.</li>
</ul>
<p>Given the following graph : </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ screen 1 ]</div>
<div class="line">                          \</div>
<div class="line">                           -&gt; [ shader 2] -&gt; [ Spout output ]</div>
</div><!-- fragment --><p>Two render lists are created, the first being </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ screen 1 ]</div>
</div><!-- fragment --><p>and the second being </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ shader 2] -&gt; [ Spout output ]</div>
</div><!-- fragment --><p>Rendering for these two <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">RenderList</a> is entirely independent - they can render at different sizes and potentially use different graphic APIs, e.g. one OpenGL and the other Vulkan. This is also done to enable threaded rendering for each of these.</p>
<p>We provide the most essential nodes for building interesting visual effects:</p><ul>
<li>A window output node (<a class="el" href="structscore_1_1gfx_1_1_screen_node.html" title="This node is used for rendering to a score::gfx::Window.">score::gfx::ScreenNode</a>).</li>
<li>Shader filters using Interactive Shader Format (<a href="https://isf.video">https://isf.video</a>).</li>
<li>Video (<a class="el" href="classscore_1_1gfx_1_1_video_node.html" title="Model for rendering a video.">score::gfx::VideoNode</a>) and image (<a class="el" href="structscore_1_1gfx_1_1_images_node.html" title="A node that renders an image to screen.">score::gfx::ImagesNode</a>) renderers.</li>
<li>The video renderer tries to do as much of the decoding as possible on the GPU: for instance YUV420, HAP, ... are decoded on the GPU. Otherwises it falls back on libavcodec to guarantee compatibility with a wide range of video formats.</li>
</ul>
<p>Other plug-ins may provide other useful things, such as NDI I/O or particle effects.</p>
<p>See GfxPlugins for information on how to create your custom nodes, visual effects and video decoders. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_audio_texture.html">AudioTexture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for audio data being sent to the GPU.  <a href="structscore_1_1gfx_1_1_audio_texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_audio_texture_upload.html">AudioTextureUpload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_camera_node.html">CameraNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for rendering a camera feed.  <a href="classscore_1_1gfx_1_1_camera_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_default_shader_material.html">DefaultShaderMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to represent a shader material following score conventions.  <a href="structscore_1_1gfx_1_1_default_shader_material.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_depth_node.html">DepthNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection between two <a class="el" href="structscore_1_1gfx_1_1_port.html" title="Port of a score::gfx::Node.">score::gfx::Port</a>.  <a href="structscore_1_1gfx_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_empty_decoder.html">EmptyDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default decoder when we do not know what to render.  <a href="structscore_1_1gfx_1_1_empty_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_full_screen_image_node.html">FullScreenImageNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_generic_node_renderer.html">GenericNodeRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic renderer.  <a href="classscore_1_1gfx_1_1_generic_node_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_g_p_u_video_decoder.html">GPUVideoDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes and renders a video frame on the GPU.  <a href="classscore_1_1gfx_1_1_g_p_u_video_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a graph of renderers.  <a href="structscore_1_1gfx_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_decoder.html">HAPDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for HAP ((c) Vidvox) decoding.  <a href="structscore_1_1gfx_1_1_h_a_p_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_default_decoder.html">HAPDefaultDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes HAP basic format.  <a href="structscore_1_1gfx_1_1_h_a_p_default_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_m_decoder.html">HAPMDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes HAP-M (HAP + alpha channel)  <a href="structscore_1_1gfx_1_1_h_a_p_m_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1image.html">image</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscore_1_1gfx_1_1_image.html" title="Image data and metadata.">Image</a> data and metadata.  <a href="structscore_1_1gfx_1_1_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_images_node.html">ImagesNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that renders an image to screen.  <a href="structscore_1_1gfx_1_1_images_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1isf__input__port__vis.html">isf_input_port_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1isf__input__size__vis.html">isf_input_size_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_i_s_f_node.html">ISFNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for Interactive Shader Format filters.  <a href="classscore_1_1gfx_1_1_i_s_f_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for meshes.  <a href="structscore_1_1gfx_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_mesh_buffers.html">MeshBuffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_message.html">Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Messages sent from the execution thread to the rendering thread.  <a href="structscore_1_1gfx_1_1_message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root data model for visual nodes.  <a href="classscore_1_1gfx_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node_model.html">NodeModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for most single-pass, simple nodes.  <a href="classscore_1_1gfx_1_1_node_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node_renderer.html">NodeRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renderer for a given node.  <a href="classscore_1_1gfx_1_1_node_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_output_node.html">OutputNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sink nodes (QWindow, spout, syphon, NDI output, ...)  <a href="classscore_1_1gfx_1_1_output_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_output_node_renderer.html">OutputNodeRenderer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_packed_decoder.html">PackedDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_pass.html">Pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_persist_sampler.html">PersistSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_phong_node.html">PhongNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful abstraction for storing a graphics pipeline and associated resource bindings.  <a href="structscore_1_1gfx_1_1_pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_plain_mesh.html">PlainMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh with only position attributes.  <a href="structscore_1_1gfx_1_1_plain_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_plain_triangle.html">PlainTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle mesh with only positions.  <a href="structscore_1_1gfx_1_1_plain_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscore_1_1gfx_1_1_port.html" title="Port of a score::gfx::Node.">Port</a> of a <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a>.  <a href="structscore_1_1gfx_1_1_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_process_node.html">ProcessNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for nodes that map to score processes.  <a href="classscore_1_1gfx_1_1_process_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_refcounted_frame.html">RefcountedFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_rendered_i_s_f_node.html">RenderedISFNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_rendered_phong_node.html">RenderedPhongNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of nodes to be rendered to an output.  <a href="classscore_1_1gfx_1_1_render_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global state associated to a rendering context.  <a href="structscore_1_1gfx_1_1_render_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a sampler and the texture currently associated with it.  <a href="structscore_1_1gfx_1_1_sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_screen_node.html">ScreenNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is used for rendering to a <a class="el" href="classscore_1_1gfx_1_1_window.html" title="A platform window in which the content is going to be rendered.">score::gfx::Window</a>.  <a href="structscore_1_1gfx_1_1_screen_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_shader_cache.html">ShaderCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache of baked QShader instances.  <a href="structscore_1_1gfx_1_1_shader_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_simple_rendered_i_s_f_node.html">SimpleRenderedISFNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_texgen_node.html">TexgenNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_text_node.html">TextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that renders text to screen.  <a href="structscore_1_1gfx_1_1_text_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_mesh.html">TexturedMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_quad.html">TexturedQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quad mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_triangle.html">TexturedTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_texture_normal_mesh.html">TextureNormalMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh with positions, texture coordinates, and normals.  <a href="structscore_1_1gfx_1_1_texture_normal_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful abstraction for storing all the data related to a render target.  <a href="structscore_1_1gfx_1_1_texture_render_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_u_y_v_y422_decoder.html">UYVY422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes UYVY422 video, mostly used for NDI.  <a href="structscore_1_1gfx_1_1_u_y_v_y422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_video_frame_reader.html">VideoFrameReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_video_frame_share.html">VideoFrameShare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node.html">VideoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for rendering a video.  <a href="classscore_1_1gfx_1_1_video_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node_base.html">VideoNodeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node_renderer.html">VideoNodeRenderer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_window.html">Window</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A platform window in which the content is going to be rendered.  <a href="classscore_1_1gfx_1_1_window.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v420_decoder.html">YUV420Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV420 videos.  <a href="structscore_1_1gfx_1_1_y_u_v420_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v422_decoder.html">YUV422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV422 videos.  <a href="structscore_1_1gfx_1_1_y_u_v422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_y_v422_decoder.html">YUYV422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUYV422 video.  <a href="structscore_1_1gfx_1_1_y_u_y_v422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5201aa54e805790d5e3efa358f6b24f5"><td class="memItemLeft" align="right" valign="top"><a id="a5201aa54e805790d5e3efa358f6b24f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b> = <a class="el" href="classscore_1_1gfx_1_1_node.html">score::gfx::Node</a> *</td></tr>
<tr class="separator:a5201aa54e805790d5e3efa358f6b24f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11263b71178ed95262505d55c400b6d"><td class="memItemLeft" align="right" valign="top"><a id="ae11263b71178ed95262505d55c400b6d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphImpl</b> = boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::directedS, <a class="el" href="classscore_1_1gfx_1_1_node.html">Vertex</a> &gt;</td></tr>
<tr class="separator:ae11263b71178ed95262505d55c400b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8184e9f9fef21824a3b281ffc644c6a5"><td class="memItemLeft" align="right" valign="top"><a id="a8184e9f9fef21824a3b281ffc644c6a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VertexMap</b> = std::map&lt; <a class="el" href="classscore_1_1gfx_1_1_node.html">score::gfx::Node</a> *, GraphImpl::vertex_descriptor &gt;</td></tr>
<tr class="separator:a8184e9f9fef21824a3b281ffc644c6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5f6171db4f1a43264850d5925376b7"><td class="memItemLeft" align="right" valign="top"><a id="aca5f6171db4f1a43264850d5925376b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>gfx_input</b> = std::variant&lt; std::monostate, ossia::value, ossia::audio_vector &gt;</td></tr>
<tr class="separator:aca5f6171db4f1a43264850d5925376b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d09e369dac94fa9ff1bba162bba575"><td class="memItemLeft" align="right" valign="top"><a id="aa7d09e369dac94fa9ff1bba162bba575"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PassMap</b> = ossia::small_vector&lt; std::pair&lt; <a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a> *, <a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a> &gt;, 2 &gt;</td></tr>
<tr class="separator:aa7d09e369dac94fa9ff1bba162bba575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d76695282728f9a95057bd6b18deccf"><td class="memItemLeft" align="right" valign="top"><a id="a9d76695282728f9a95057bd6b18deccf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PassOutput</b> = std::variant&lt; <a class="el" href="structscore_1_1gfx_1_1_persist_sampler.html">PersistSampler</a>, <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &gt;</td></tr>
<tr class="separator:a9d76695282728f9a95057bd6b18deccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a3abb86a1bf360e72c0abdcb34af3"><td class="memItemLeft" align="right" valign="top"><a id="a269a3abb86a1bf360e72c0abdcb34af3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ValueVariant</b> = std::variant&lt; std::monostate, float, ossia::vec2f, ossia::vec3f, ossia::vec4f, <a class="el" href="structscore_1_1gfx_1_1image.html">image</a> &gt;</td></tr>
<tr class="separator:a269a3abb86a1bf360e72c0abdcb34af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:add5f72745723b9cdbc8038d333a059dc"><td class="memItemLeft" align="right" valign="top"><a id="add5f72745723b9cdbc8038d333a059dc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ImageMode</b> { <b>Single</b>, 
<b>Clamped</b>, 
<b>Tiled</b>, 
<b>Mirrored</b>
 }</td></tr>
<tr class="separator:add5f72745723b9cdbc8038d333a059dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="memItemLeft" align="right" valign="top"><a id="a5b6a96306e1a02ccc56d8bb785bc6734"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a5b6a96306e1a02ccc56d8bb785bc6734">GraphicsApi</a> { <br />
&#160;&#160;<b>Null</b>, 
<b>OpenGL</b>, 
<b>Vulkan</b>, 
<b>D3D11</b>, 
<br />
&#160;&#160;<b>Metal</b>
<br />
 }</td></tr>
<tr class="memdesc:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available graphics APIs to use. <br /></td></tr>
<tr class="separator:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="memItemLeft" align="right" valign="top"><a id="ac7b0a6847f2f616b12a8fe08a1229b58"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ac7b0a6847f2f616b12a8fe08a1229b58">ScaleMode</a> { <b>Original</b>, 
<b>BlackBars</b>, 
<b>Fill</b>, 
<b>Stretch</b>
 }</td></tr>
<tr class="memdesc:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to resize a texture to adapt it to a viewport. <br /></td></tr>
<tr class="separator:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3fecbd0a1860c0bef60edbfea54512"><td class="memItemLeft" align="right" valign="top"><a id="aee3fecbd0a1860c0bef60edbfea54512"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Types</b> { <br />
&#160;&#160;<b>Empty</b>, 
<b>Int</b>, 
<b>Float</b>, 
<b>Vec2</b>, 
<br />
&#160;&#160;<b>Vec3</b>, 
<b>Vec4</b>, 
<b>Image</b>, 
<b>Audio</b>, 
<br />
&#160;&#160;<b>Camera</b>
<br />
 }</td></tr>
<tr class="separator:aee3fecbd0a1860c0bef60edbfea54512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea6ff7bc9d36b438ec03fa9cc271e929"><td class="memItemLeft" align="right" valign="top"><a id="aea6ff7bc9d36b438ec03fa9cc271e929"></a>
QVulkanInstance *&#160;</td><td class="memItemRight" valign="bottom"><b>staticVulkanInstance</b> ()</td></tr>
<tr class="separator:aea6ff7bc9d36b438ec03fa9cc271e929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade240faed5ca4c785087262e25bfe848"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ade240faed5ca4c785087262e25bfe848">__attribute__</a> ((packed)) ProcessUBO</td></tr>
<tr class="memdesc:ade240faed5ca4c785087262e25bfe848"><td class="mdescLeft">&#160;</td><td class="mdescRight">UBO specific to individual processes / nodes.  <a href="namespacescore_1_1gfx.html#ade240faed5ca4c785087262e25bfe848">More...</a><br /></td></tr>
<tr class="separator:ade240faed5ca4c785087262e25bfe848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a05763dd9e30cdb72f2c3183359da1"><td class="memTemplParams" colspan="2"><a id="a15a05763dd9e30cdb72f2c3183359da1"></a>
template&lt;typename Graph_T , typename IO &gt; </td></tr>
<tr class="memitem:a15a05763dd9e30cdb72f2c3183359da1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_graph</b> (Graph_T &amp;g, IO &amp;stream)</td></tr>
<tr class="separator:a15a05763dd9e30cdb72f2c3183359da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93637639b98f42b59cd9bb0b140fb5ca"><td class="memItemLeft" align="right" valign="top"><a id="a93637639b98f42b59cd9bb0b140fb5ca"></a>
<a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a93637639b98f42b59cd9bb0b140fb5ca">createRenderTarget</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;state, QRhiTexture *tex)</td></tr>
<tr class="memdesc:a93637639b98f42b59cd9bb0b140fb5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render target from a texture. <br /></td></tr>
<tr class="separator:a93637639b98f42b59cd9bb0b140fb5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092fb509db323bc846a47e79bbd6a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a0092fb509db323bc846a47e79bbd6a0e">createRenderTarget</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;state, QRhiTexture::Format fmt, QSize sz)</td></tr>
<tr class="memdesc:a0092fb509db323bc846a47e79bbd6a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render target from a texture format and size.  <a href="namespacescore_1_1gfx.html#a0092fb509db323bc846a47e79bbd6a0e">More...</a><br /></td></tr>
<tr class="separator:a0092fb509db323bc846a47e79bbd6a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b7d6c1d8b23ae672b17d89275575de"><td class="memItemLeft" align="right" valign="top"><a id="a64b7d6c1d8b23ae672b17d89275575de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a64b7d6c1d8b23ae672b17d89275575de">replaceSampler</a> (QRhiShaderResourceBindings &amp;, QRhiSampler *oldSampler, QRhiSampler *newSampler)</td></tr>
<tr class="memdesc:a64b7d6c1d8b23ae672b17d89275575de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a sampler. <br /></td></tr>
<tr class="separator:a64b7d6c1d8b23ae672b17d89275575de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b178205d9b5f7a8b713bf052e4d3ba1"><td class="memItemLeft" align="right" valign="top"><a id="a9b178205d9b5f7a8b713bf052e4d3ba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a9b178205d9b5f7a8b713bf052e4d3ba1">replaceTexture</a> (QRhiShaderResourceBindings &amp;, QRhiSampler *sampler, QRhiTexture *newTexture)</td></tr>
<tr class="memdesc:a9b178205d9b5f7a8b713bf052e4d3ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the texture currently bound to a sampler. <br /></td></tr>
<tr class="separator:a9b178205d9b5f7a8b713bf052e4d3ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababc44774d82182d52016c90d469eb49"><td class="memItemLeft" align="right" valign="top"><a id="ababc44774d82182d52016c90d469eb49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ababc44774d82182d52016c90d469eb49">replaceTexture</a> (QRhiShaderResourceBindings &amp;srb, QRhiTexture *old_tex, QRhiTexture *new_tex)</td></tr>
<tr class="memdesc:ababc44774d82182d52016c90d469eb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a texture by another in a set of bindings. <br /></td></tr>
<tr class="separator:ababc44774d82182d52016c90d469eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fe885aafe546214b24385dda52e77"><td class="memItemLeft" align="right" valign="top"><a id="a5b9fe885aafe546214b24385dda52e77"></a>
<a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildPipeline</b> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const QShader &amp;vertexS, const QShader &amp;fragmentS, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiShaderResourceBindings *srb)</td></tr>
<tr class="separator:a5b9fe885aafe546214b24385dda52e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbb3b91881071ea4cd05082871a5e69"><td class="memItemLeft" align="right" valign="top"><a id="afcbb3b91881071ea4cd05082871a5e69"></a>
QRhiShaderResourceBindings *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#afcbb3b91881071ea4cd05082871a5e69">createDefaultBindings</a> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiBuffer *processUBO, QRhiBuffer *materialUBO, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a> &gt; &amp;samplers)</td></tr>
<tr class="memdesc:afcbb3b91881071ea4cd05082871a5e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create bindings following the score conventions for shaders and materials. <br /></td></tr>
<tr class="separator:afcbb3b91881071ea4cd05082871a5e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cee3a6e153623e3259a1b88ffcafa44"><td class="memItemLeft" align="right" valign="top"><a id="a1cee3a6e153623e3259a1b88ffcafa44"></a>
<a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a1cee3a6e153623e3259a1b88ffcafa44">buildPipeline</a> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const QShader &amp;vertexS, const QShader &amp;fragmentS, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiBuffer *processUBO, QRhiBuffer *materialUBO, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a> &gt; &amp;samplers)</td></tr>
<tr class="memdesc:a1cee3a6e153623e3259a1b88ffcafa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pipeline following the score conventions for shaders and materials. <br /></td></tr>
<tr class="separator:a1cee3a6e153623e3259a1b88ffcafa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0480b60a305df61d27a6953097584582"><td class="memItemLeft" align="right" valign="top">std::pair&lt; QShader, QShader &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a0480b60a305df61d27a6953097584582">makeShaders</a> (QString vert, QString frag)</td></tr>
<tr class="memdesc:a0480b60a305df61d27a6953097584582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of compiled vertex / fragment shaders from GLSL 4.5 sources.  <a href="namespacescore_1_1gfx.html#a0480b60a305df61d27a6953097584582">More...</a><br /></td></tr>
<tr class="separator:a0480b60a305df61d27a6953097584582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a149915dafb47e82c0aaa177396e537"><td class="memItemLeft" align="right" valign="top">QShader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a5a149915dafb47e82c0aaa177396e537">makeCompute</a> (QString compt)</td></tr>
<tr class="memdesc:a5a149915dafb47e82c0aaa177396e537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a compute shader.  <a href="namespacescore_1_1gfx.html#a5a149915dafb47e82c0aaa177396e537">More...</a><br /></td></tr>
<tr class="separator:a5a149915dafb47e82c0aaa177396e537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492c024019592e9c74e2eaa88d6282c"><td class="memItemLeft" align="right" valign="top"><a id="a4492c024019592e9c74e2eaa88d6282c"></a>
QSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a4492c024019592e9c74e2eaa88d6282c">resizeTextureSize</a> (QSize img, int min, int max) noexcept</td></tr>
<tr class="memdesc:a4492c024019592e9c74e2eaa88d6282c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the size of a texture to fit within GPU limits. <br /></td></tr>
<tr class="separator:a4492c024019592e9c74e2eaa88d6282c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace27fba3b7ac24cd0777898e7eac1e53"><td class="memItemLeft" align="right" valign="top"><a id="ace27fba3b7ac24cd0777898e7eac1e53"></a>
QImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ace27fba3b7ac24cd0777898e7eac1e53">resizeTexture</a> (const QImage &amp;img, int min, int max) noexcept</td></tr>
<tr class="memdesc:ace27fba3b7ac24cd0777898e7eac1e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a texture to fit within GPU limits. <br /></td></tr>
<tr class="separator:ace27fba3b7ac24cd0777898e7eac1e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23b625995fa073d355e628cd909623a"><td class="memItemLeft" align="right" valign="top"><a id="ae23b625995fa073d355e628cd909623a"></a>
QSizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ae23b625995fa073d355e628cd909623a">computeScale</a> (<a class="el" href="namespacescore_1_1gfx.html#ac7b0a6847f2f616b12a8fe08a1229b58">score::gfx::ScaleMode</a> mode, QSizeF viewport, QSizeF texture)</td></tr>
<tr class="memdesc:ae23b625995fa073d355e628cd909623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comput the scale to apply to a texture so that it fits in a GL viewport. <br /></td></tr>
<tr class="separator:ae23b625995fa073d355e628cd909623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac6dcff8c5e43627a9801cd96b565e1"><td class="memItemLeft" align="right" valign="top"><a id="a9ac6dcff8c5e43627a9801cd96b565e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyMatrix</b> (const QMatrix4x4 &amp;mat, float *ptr) noexcept</td></tr>
<tr class="separator:a9ac6dcff8c5e43627a9801cd96b565e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d873668123906da344616f30f020f9"><td class="memItemLeft" align="right" valign="top"><a id="a63d873668123906da344616f30f020f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyMatrix</b> (const QMatrix3x3 &amp;mat, float *ptr) noexcept</td></tr>
<tr class="separator:a63d873668123906da344616f30f020f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a57170d1e694379b976b929a2b187558a"><td class="memItemLeft" align="right" valign="top"><a id="a57170d1e694379b976b929a2b187558a"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>frag</b></td></tr>
<tr class="separator:a57170d1e694379b976b929a2b187558a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ade240faed5ca4c785087262e25bfe848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade240faed5ca4c785087262e25bfe848">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct score::gfx::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(packed)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UBO specific to individual processes / nodes. </p>
<p>UBO shared across all entities shown on the same output.</p>
<p>UBO shared across all entities shown with the same camera. </p>

</div>
</div>
<a id="a0092fb509db323bc846a47e79bbd6a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0092fb509db323bc846a47e79bbd6a0e">&#9670;&nbsp;</a></span>createRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCORE_PLUGIN_GFX_EXPORT <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> score::gfx::createRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QRhiTexture::Format&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSize&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render target from a texture format and size. </p>
<p>This function will also create a texture. </p>

</div>
</div>
<a id="a5a149915dafb47e82c0aaa177396e537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a149915dafb47e82c0aaa177396e537">&#9670;&nbsp;</a></span>makeCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCORE_PLUGIN_GFX_EXPORT QShader score::gfx::makeCompute </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>compt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a compute shader. </p>
<p>Note: this function will throw if the shader is invalid. </p>

</div>
</div>
<a id="a0480b60a305df61d27a6953097584582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0480b60a305df61d27a6953097584582">&#9670;&nbsp;</a></span>makeShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCORE_PLUGIN_GFX_EXPORT std::pair&lt; QShader, QShader &gt; score::gfx::makeShaders </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>vert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>frag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of compiled vertex / fragment shaders from GLSL 4.5 sources. </p>
<p>Note: this function will throw if a shader is invalid. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
