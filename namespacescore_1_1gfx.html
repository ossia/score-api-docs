<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>score: score::gfx Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="http://ossia.io">score </a>
                </div>
                <ul class="nav navbar-nav">
                  <li class="active"><a href="index.html">Home</a></li>
                  <li><a href="classes.html">Classes</a></li>
                  <li><a href="namespaces.html">Namespaces</a></li>
                  <li><a href="files.html">Files</a></li>
                </ul>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacescore_1_1gfx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">score::gfx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Graphics rendering pipeline for ossia score.  
<a href="namespacescore_1_1gfx.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graphics rendering pipeline for ossia score. </p>
<p>This namespace provides a rendering pipeline for GPU visuals, by the way of a rendering graph. The implementation uses the Qt RHI:</p>
<p><a href="https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d">https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d</a></p>
<p>It is mainly designed for rendering a succession of visual effects, not rendering arbitrary 3D. Shaders are written in the usual glslang -&gt; spirv-cross fashion, with GLSL #version 450. They are then translated automatically to SPIRV, Metal, GLSL or D3D11 shaders.</p>
<p>The overall design is as follows :</p>
<ul>
<li>Elements to render are represented as nodes to a graph: <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a></li>
<li>Input ports are the uniforms and input textures &amp; audio data.</li>
<li>Output ports generally are just the texture we are rendering to.</li>
<li><a class="el" href="structscore_1_1gfx_1_1_graph.html" title="Represents a graph of renderers.">score::gfx::Graph</a> contains all the nodes, and relationships between these nodes.</li>
<li>For each output sink (a window surface, an NDI or Spout output...), a <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">score::gfx::RenderList</a> is created. It contains all the nodes to render for a given output.</li>
<li>For each <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a>, the <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">score::gfx::RenderList</a> creates a <a class="el" href="classscore_1_1gfx_1_1_node_renderer.html" title="Renderer for a given node.">score::gfx::NodeRenderer</a> which contains the actual GPU resource handles for the sink.</li>
</ul>
<p>Given the following graph : </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ screen 1 ]</div>
<div class="line">                          \</div>
<div class="line">                           -&gt; [ shader 2] -&gt; [ Spout output ]</div>
</div><!-- fragment --><p>Two render lists are created, the first being </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ screen 1 ]</div>
</div><!-- fragment --><p>and the second being </p><div class="fragment"><div class="line">[ video ] -&gt; [ shader 1 ] -&gt; [ shader 2] -&gt; [ Spout output ]</div>
</div><!-- fragment --><p>Rendering for these two <a class="el" href="classscore_1_1gfx_1_1_render_list.html" title="List of nodes to be rendered to an output.">RenderList</a> is entirely independent - they can render at different sizes and potentially use different graphic APIs, e.g. one OpenGL and the other Vulkan. This is also done to enable threaded rendering for each of these.</p>
<p>We provide the most essential nodes for building interesting visual effects:</p><ul>
<li>A window output node (<a class="el" href="structscore_1_1gfx_1_1_screen_node.html" title="This node is used for rendering to a score::gfx::Window.">score::gfx::ScreenNode</a>).</li>
<li>Shader filters using Interactive Shader Format (<a href="https://isf.video">https://isf.video</a>).</li>
<li>Video (<a class="el" href="classscore_1_1gfx_1_1_video_node.html" title="Model for rendering a video.">score::gfx::VideoNode</a>) and image (<a class="el" href="structscore_1_1gfx_1_1_images_node.html" title="A node that renders an image to screen.">score::gfx::ImagesNode</a>) renderers.</li>
<li>The video renderer tries to do as much of the decoding as possible on the GPU: for instance YUV420, HAP, ... are decoded on the GPU. Otherwises it falls back on libavcodec to guarantee compatibility with a wide range of video formats.</li>
</ul>
<p>Other plug-ins may provide other useful things, such as NDI I/O or particle effects.</p>
<p>See GfxPlugins for information on how to create your custom nodes, visual effects and video decoders. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_process_u_b_o.html">ProcessUBO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UBO specific to individual processes / nodes.  <a href="structscore_1_1gfx_1_1_process_u_b_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_model_camera_u_b_o.html">ModelCameraUBO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UBO shared across all entities shown with the same camera.  <a href="structscore_1_1gfx_1_1_model_camera_u_b_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_output_u_b_o.html">OutputUBO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UBO shared across all entities shown on the same output.  <a href="structscore_1_1gfx_1_1_output_u_b_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_custom_mesh.html">CustomMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_g_p_u_video_decoder.html">GPUVideoDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes and renders a video frame on the GPU.  <a href="classscore_1_1gfx_1_1_g_p_u_video_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_empty_decoder.html">EmptyDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default decoder when we do not know what to render.  <a href="structscore_1_1gfx_1_1_empty_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_decoder.html">HAPDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for HAP ((c) Vidvox) decoding.  <a href="structscore_1_1gfx_1_1_h_a_p_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_default_decoder.html">HAPDefaultDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes HAP basic format.  <a href="structscore_1_1gfx_1_1_h_a_p_default_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_h_a_p_m_decoder.html">HAPMDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes HAP-M (HAP + alpha channel)  <a href="structscore_1_1gfx_1_1_h_a_p_m_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_n_v12_decoder.html">NV12Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes NV12 videos.  <a href="structscore_1_1gfx_1_1_n_v12_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_packed_decoder.html">PackedDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_planar_decoder.html">PlanarDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_packed_rect_decoder.html">PackedRectDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v420_decoder.html">YUV420Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV420 videos.  <a href="structscore_1_1gfx_1_1_y_u_v420_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v420_p10_decoder.html">YUV420P10Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV420 videos.  <a href="structscore_1_1gfx_1_1_y_u_v420_p10_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v422_decoder.html">YUV422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV422 videos.  <a href="structscore_1_1gfx_1_1_y_u_v422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_v422_p10_decoder.html">YUV422P10Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUV422 videos.  <a href="structscore_1_1gfx_1_1_y_u_v422_p10_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_y_u_y_v422_decoder.html">YUYV422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes YUYV422 video.  <a href="structscore_1_1gfx_1_1_y_u_y_v422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_u_y_v_y422_decoder.html">UYVY422Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes UYVY422 video, mostly used for NDI.  <a href="structscore_1_1gfx_1_1_u_y_v_y422_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_depth_node.html">DepthNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a graph of renderers.  <a href="structscore_1_1gfx_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_images_node.html">ImagesNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that renders an image to screen.  <a href="structscore_1_1gfx_1_1_images_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_full_screen_image_node.html">FullScreenImageNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1isf__input__size__vis.html">isf_input_size_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1isf__input__port__vis.html">isf_input_port_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_i_s_f_node.html">ISFNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for Interactive Shader Format filters.  <a href="classscore_1_1gfx_1_1_i_s_f_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_mesh_buffers.html">MeshBuffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for meshes.  <a href="structscore_1_1gfx_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_basic_mesh.html">BasicMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_plain_mesh.html">PlainMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh with only position attributes.  <a href="structscore_1_1gfx_1_1_plain_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_mesh.html">TexturedMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_plain_triangle.html">PlainTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle mesh with only positions.  <a href="structscore_1_1gfx_1_1_plain_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_triangle.html">TexturedTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangle mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_textured_quad.html">TexturedQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quad mesh with positions and texture coordinates.  <a href="structscore_1_1gfx_1_1_textured_quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_timings.html">Timings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Messages sent from the execution thread to the rendering thread.  <a href="structscore_1_1gfx_1_1_timings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_message.html">Message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root data model for visual nodes.  <a href="classscore_1_1gfx_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_process_node.html">ProcessNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for nodes that map to score processes.  <a href="classscore_1_1gfx_1_1_process_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node_model.html">NodeModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for most single-pass, simple nodes.  <a href="classscore_1_1gfx_1_1_node_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_node_renderer.html">NodeRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renderer for a given node.  <a href="classscore_1_1gfx_1_1_node_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_generic_node_renderer.html">GenericNodeRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic renderer.  <a href="classscore_1_1gfx_1_1_generic_node_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_output_node_renderer.html">OutputNodeRenderer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_output_node.html">OutputNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sink nodes (QWindow, spout, syphon, NDI output, ...)  <a href="classscore_1_1gfx_1_1_output_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_rendered_phong_node.html">RenderedPhongNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_phong_node.html">PhongNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_pass.html">Pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_persist_sampler.html">PersistSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_audio_texture_upload.html">AudioTextureUpload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_rendered_i_s_f_node.html">RenderedISFNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_simple_rendered_i_s_f_node.html">SimpleRenderedISFNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of nodes to be rendered to an output.  <a href="classscore_1_1gfx_1_1_render_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global state associated to a rendering context.  <a href="structscore_1_1gfx_1_1_render_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_screen_node.html">ScreenNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is used for rendering to a <a class="el" href="classscore_1_1gfx_1_1_window.html" title="A platform window in which the content is going to be rendered.">score::gfx::Window</a>.  <a href="structscore_1_1gfx_1_1_screen_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_shader_cache.html">ShaderCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache of baked QShader instances.  <a href="structscore_1_1gfx_1_1_shader_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_texgen_node.html">TexgenNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_text_node.html">TextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that renders text to screen.  <a href="structscore_1_1gfx_1_1_text_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1image.html">image</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1geometry.html">geometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a sampler and the texture currently associated with it.  <a href="structscore_1_1gfx_1_1_sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_audio_texture.html">AudioTexture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data model for audio data being sent to the GPU.  <a href="structscore_1_1gfx_1_1_audio_texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscore_1_1gfx_1_1_port.html" title="Port of a score::gfx::Node.">Port</a> of a <a class="el" href="classscore_1_1gfx_1_1_node.html" title="Root data model for visual nodes.">score::gfx::Node</a>.  <a href="structscore_1_1gfx_1_1_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection between two <a class="el" href="structscore_1_1gfx_1_1_port.html" title="Port of a score::gfx::Node.">score::gfx::Port</a>.  <a href="structscore_1_1gfx_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful abstraction for storing a graphics pipeline and associated resource bindings.  <a href="structscore_1_1gfx_1_1_pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful abstraction for storing all the data related to a render target.  <a href="structscore_1_1gfx_1_1_texture_render_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscore_1_1gfx_1_1_image.html" title="Image data and metadata.">Image</a> data and metadata.  <a href="structscore_1_1gfx_1_1_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_default_shader_material.html">DefaultShaderMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to represent a shader material following score conventions.  <a href="structscore_1_1gfx_1_1_default_shader_material.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_refcounted_frame.html">RefcountedFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_video_frame_share.html">VideoFrameShare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscore_1_1gfx_1_1_video_frame_reader.html">VideoFrameReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node_base.html">VideoNodeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node.html">VideoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for rendering a video.  <a href="classscore_1_1gfx_1_1_video_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_camera_node.html">CameraNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for rendering a camera feed.  <a href="classscore_1_1gfx_1_1_camera_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_video_node_renderer.html">VideoNodeRenderer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscore_1_1gfx_1_1_window.html">Window</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A platform window in which the content is going to be rendered.  <a href="classscore_1_1gfx_1_1_window.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5201aa54e805790d5e3efa358f6b24f5"><td class="memItemLeft" align="right" valign="top"><a id="a5201aa54e805790d5e3efa358f6b24f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b> = <a class="el" href="classscore_1_1gfx_1_1_node.html">score::gfx::Node</a> *</td></tr>
<tr class="separator:a5201aa54e805790d5e3efa358f6b24f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8199ca6c6a8d79a55b9cb689e16e48ef"><td class="memItemLeft" align="right" valign="top"><a id="a8199ca6c6a8d79a55b9cb689e16e48ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphImpl</b> = boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::directedS, <a class="el" href="classscore_1_1gfx_1_1_node.html">Vertex</a> &gt;</td></tr>
<tr class="separator:a8199ca6c6a8d79a55b9cb689e16e48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8753b1046f64ecbd2499300731d4c3b"><td class="memItemLeft" align="right" valign="top"><a id="ad8753b1046f64ecbd2499300731d4c3b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VertexMap</b> = ossia::hash_map&lt; <a class="el" href="classscore_1_1gfx_1_1_node.html">score::gfx::Node</a> *, GraphImpl::vertex_descriptor &gt;</td></tr>
<tr class="separator:ad8753b1046f64ecbd2499300731d4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada78aafdea9354de381f09cb036c4ed6"><td class="memItemLeft" align="right" valign="top"><a id="ada78aafdea9354de381f09cb036c4ed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>gfx_input</b> = ossia::slow_variant&lt; ossia::monostate, ossia::value, ossia::audio_vector, ossia::mesh_list_ptr, ossia::transform3d &gt;</td></tr>
<tr class="separator:ada78aafdea9354de381f09cb036c4ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d09e369dac94fa9ff1bba162bba575"><td class="memItemLeft" align="right" valign="top"><a id="aa7d09e369dac94fa9ff1bba162bba575"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PassMap</b> = ossia::small_vector&lt; std::pair&lt; <a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a> *, <a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a> &gt;, 2 &gt;</td></tr>
<tr class="separator:aa7d09e369dac94fa9ff1bba162bba575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4b2f8caa26e18682dfcbf59093844"><td class="memItemLeft" align="right" valign="top"><a id="aa6d4b2f8caa26e18682dfcbf59093844"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PassOutput</b> = ossia::variant&lt; <a class="el" href="structscore_1_1gfx_1_1_persist_sampler.html">PersistSampler</a>, <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &gt;</td></tr>
<tr class="separator:aa6d4b2f8caa26e18682dfcbf59093844"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:add5f72745723b9cdbc8038d333a059dc"><td class="memItemLeft" align="right" valign="top"><a id="add5f72745723b9cdbc8038d333a059dc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ImageMode</b> { <b>Single</b>
, <b>Clamped</b>
, <b>Tiled</b>
, <b>Mirrored</b>
 }</td></tr>
<tr class="separator:add5f72745723b9cdbc8038d333a059dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="memItemLeft" align="right" valign="top"><a id="a5b6a96306e1a02ccc56d8bb785bc6734"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a5b6a96306e1a02ccc56d8bb785bc6734">GraphicsApi</a> { <br />
&#160;&#160;<b>Null</b>
, <b>OpenGL</b>
, <b>Vulkan</b>
, <b>D3D11</b>
, <br />
&#160;&#160;<b>Metal</b>
<br />
 }</td></tr>
<tr class="memdesc:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available graphics APIs to use. <br /></td></tr>
<tr class="separator:a5b6a96306e1a02ccc56d8bb785bc6734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="memItemLeft" align="right" valign="top"><a id="ac7b0a6847f2f616b12a8fe08a1229b58"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ac7b0a6847f2f616b12a8fe08a1229b58">ScaleMode</a> { <b>Original</b>
, <b>BlackBars</b>
, <b>Fill</b>
, <b>Stretch</b>
 }</td></tr>
<tr class="memdesc:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to resize a texture to adapt it to a viewport. <br /></td></tr>
<tr class="separator:ac7b0a6847f2f616b12a8fe08a1229b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3fecbd0a1860c0bef60edbfea54512"><td class="memItemLeft" align="right" valign="top"><a id="aee3fecbd0a1860c0bef60edbfea54512"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Types</b> { <br />
&#160;&#160;<b>Empty</b>
, <b>Int</b>
, <b>Float</b>
, <b>Vec2</b>
, <br />
&#160;&#160;<b>Vec3</b>
, <b>Vec4</b>
, <b>Image</b>
, <b>Audio</b>
, <br />
&#160;&#160;<b>Camera</b>
, <b>Geometry</b>
<br />
 }</td></tr>
<tr class="separator:aee3fecbd0a1860c0bef60edbfea54512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15a05763dd9e30cdb72f2c3183359da1"><td class="memTemplParams" colspan="2"><a id="a15a05763dd9e30cdb72f2c3183359da1"></a>
template&lt;typename Graph_T , typename IO &gt; </td></tr>
<tr class="memitem:a15a05763dd9e30cdb72f2c3183359da1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_graph</b> (Graph_T &amp;g, IO &amp;stream)</td></tr>
<tr class="separator:a15a05763dd9e30cdb72f2c3183359da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159812d1805bbff5c888b3e565338b2"><td class="memItemLeft" align="right" valign="top"><a id="a3159812d1805bbff5c888b3e565338b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Q_DECLARE_OPERATORS_FOR_FLAGS</b> (Mesh::Flags)</td></tr>
<tr class="separator:a3159812d1805bbff5c888b3e565338b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d745ab483c5aa3b5e3b39deae8036"><td class="memItemLeft" align="right" valign="top"><a id="ac61d745ab483c5aa3b5e3b39deae8036"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>defaultPassesInit</b> (PassMap &amp;passes, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a> * &gt; &amp;edges, <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const QShader &amp;v, const QShader &amp;f, QRhiBuffer *processUBO, QRhiBuffer *matUBO, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a> &gt; &amp;samplers)</td></tr>
<tr class="separator:ac61d745ab483c5aa3b5e3b39deae8036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ca5f0c2f34795e323fcb0275ee374"><td class="memItemLeft" align="right" valign="top"><a id="aab3ca5f0c2f34795e323fcb0275ee374"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>defaultRenderPass</b> (<a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const <a class="el" href="structscore_1_1gfx_1_1_mesh_buffers.html">MeshBuffers</a> &amp;bufs, QRhiCommandBuffer &amp;cb, <a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a> &amp;edge, PassMap &amp;passes)</td></tr>
<tr class="separator:aab3ca5f0c2f34795e323fcb0275ee374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a58880047dd23a1e25e529168536d2b"><td class="memItemLeft" align="right" valign="top"><a id="a0a58880047dd23a1e25e529168536d2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quadRenderPass</b> (<a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh_buffers.html">MeshBuffers</a> &amp;bufs, QRhiCommandBuffer &amp;cb, <a class="el" href="structscore_1_1gfx_1_1_edge.html">Edge</a> &amp;edge, PassMap &amp;passes)</td></tr>
<tr class="separator:a0a58880047dd23a1e25e529168536d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c2d8745417c6870c03acad5edff82b"><td class="memItemLeft" align="right" valign="top"><a id="ab0c2d8745417c6870c03acad5edff82b"></a>
<a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ab0c2d8745417c6870c03acad5edff82b">createRenderTarget</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;state, QRhiTexture *tex, int samples)</td></tr>
<tr class="memdesc:ab0c2d8745417c6870c03acad5edff82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render target from a texture. <br /></td></tr>
<tr class="separator:ab0c2d8745417c6870c03acad5edff82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7541026217601bd51343feafdac49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a2a7541026217601bd51343feafdac49c">createRenderTarget</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;state, QRhiTexture::Format fmt, QSize sz, int samples, QRhiTexture::Flags={})</td></tr>
<tr class="memdesc:a2a7541026217601bd51343feafdac49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render target from a texture format and size.  <a href="namespacescore_1_1gfx.html#a2a7541026217601bd51343feafdac49c">More...</a><br /></td></tr>
<tr class="separator:a2a7541026217601bd51343feafdac49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469ecc0c017a3f7d8eff4b94510e2eba"><td class="memItemLeft" align="right" valign="top"><a id="a469ecc0c017a3f7d8eff4b94510e2eba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceBuffer</b> (std::vector&lt; QRhiShaderResourceBinding &gt; &amp;tmp, int binding, QRhiBuffer *newBuffer)</td></tr>
<tr class="separator:a469ecc0c017a3f7d8eff4b94510e2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40284f06c654dae8eba76828c80ab8ca"><td class="memItemLeft" align="right" valign="top"><a id="a40284f06c654dae8eba76828c80ab8ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceSampler</b> (std::vector&lt; QRhiShaderResourceBinding &gt; &amp;tmp, int binding, QRhiSampler *newSampler)</td></tr>
<tr class="separator:a40284f06c654dae8eba76828c80ab8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce230fa125e2d0cf45bd13bc694d550"><td class="memItemLeft" align="right" valign="top"><a id="afce230fa125e2d0cf45bd13bc694d550"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceTexture</b> (std::vector&lt; QRhiShaderResourceBinding &gt; &amp;tmp, int binding, QRhiTexture *newTexture)</td></tr>
<tr class="separator:afce230fa125e2d0cf45bd13bc694d550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcebd83bf87635fd9f1d234bc7dc503"><td class="memItemLeft" align="right" valign="top"><a id="a7fcebd83bf87635fd9f1d234bc7dc503"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceBuffer</b> (QRhiShaderResourceBindings &amp;srb, int binding, QRhiBuffer *newBuffer)</td></tr>
<tr class="separator:a7fcebd83bf87635fd9f1d234bc7dc503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a93bc3a58d7a54f2ef93dc475063bab"><td class="memItemLeft" align="right" valign="top"><a id="a6a93bc3a58d7a54f2ef93dc475063bab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceSampler</b> (QRhiShaderResourceBindings &amp;srb, int binding, QRhiSampler *newSampler)</td></tr>
<tr class="separator:a6a93bc3a58d7a54f2ef93dc475063bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7531cc88f934c654b9b85cd7adac95e"><td class="memItemLeft" align="right" valign="top"><a id="ac7531cc88f934c654b9b85cd7adac95e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceTexture</b> (QRhiShaderResourceBindings &amp;srb, int binding, QRhiTexture *newTexture)</td></tr>
<tr class="separator:ac7531cc88f934c654b9b85cd7adac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba9e4c253f3bcae70e1d36cf469be3"><td class="memItemLeft" align="right" valign="top"><a id="a35ba9e4c253f3bcae70e1d36cf469be3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a35ba9e4c253f3bcae70e1d36cf469be3">replaceSampler</a> (QRhiShaderResourceBindings &amp;, QRhiSampler *oldSampler, QRhiSampler *newSampler)</td></tr>
<tr class="memdesc:a35ba9e4c253f3bcae70e1d36cf469be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a sampler. <br /></td></tr>
<tr class="separator:a35ba9e4c253f3bcae70e1d36cf469be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a120e4b5553a7ffeaeb10c7208b2e9"><td class="memItemLeft" align="right" valign="top"><a id="af4a120e4b5553a7ffeaeb10c7208b2e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#af4a120e4b5553a7ffeaeb10c7208b2e9">replaceTexture</a> (QRhiShaderResourceBindings &amp;, QRhiSampler *sampler, QRhiTexture *newTexture)</td></tr>
<tr class="memdesc:af4a120e4b5553a7ffeaeb10c7208b2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the texture currently bound to a sampler. <br /></td></tr>
<tr class="separator:af4a120e4b5553a7ffeaeb10c7208b2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab4e37b245596d7fbb9023414aa622"><td class="memItemLeft" align="right" valign="top"><a id="a78ab4e37b245596d7fbb9023414aa622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a78ab4e37b245596d7fbb9023414aa622">replaceTexture</a> (QRhiShaderResourceBindings &amp;srb, QRhiTexture *old_tex, QRhiTexture *new_tex)</td></tr>
<tr class="memdesc:a78ab4e37b245596d7fbb9023414aa622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a texture by another in a set of bindings. <br /></td></tr>
<tr class="separator:a78ab4e37b245596d7fbb9023414aa622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fe885aafe546214b24385dda52e77"><td class="memItemLeft" align="right" valign="top"><a id="a5b9fe885aafe546214b24385dda52e77"></a>
<a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildPipeline</b> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const QShader &amp;vertexS, const QShader &amp;fragmentS, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiShaderResourceBindings *srb)</td></tr>
<tr class="separator:a5b9fe885aafe546214b24385dda52e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b8a916f607c31ba1d9c206da630bcd"><td class="memItemLeft" align="right" valign="top"><a id="a28b8a916f607c31ba1d9c206da630bcd"></a>
QRhiShaderResourceBindings *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a28b8a916f607c31ba1d9c206da630bcd">createDefaultBindings</a> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiBuffer *processUBO, QRhiBuffer *materialUBO, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a> &gt; &amp;samplers)</td></tr>
<tr class="memdesc:a28b8a916f607c31ba1d9c206da630bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create bindings following the score conventions for shaders and materials. <br /></td></tr>
<tr class="separator:a28b8a916f607c31ba1d9c206da630bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24838f6c2d71668a1cc869bd540a0a0c"><td class="memItemLeft" align="right" valign="top"><a id="a24838f6c2d71668a1cc869bd540a0a0c"></a>
<a class="el" href="structscore_1_1gfx_1_1_pipeline.html">Pipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a24838f6c2d71668a1cc869bd540a0a0c">buildPipeline</a> (const <a class="el" href="classscore_1_1gfx_1_1_render_list.html">RenderList</a> &amp;renderer, const <a class="el" href="structscore_1_1gfx_1_1_mesh.html">Mesh</a> &amp;mesh, const QShader &amp;vertexS, const QShader &amp;fragmentS, const <a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> &amp;rt, QRhiBuffer *processUBO, QRhiBuffer *materialUBO, const std::vector&lt; <a class="el" href="structscore_1_1gfx_1_1_sampler.html">Sampler</a> &gt; &amp;samplers)</td></tr>
<tr class="memdesc:a24838f6c2d71668a1cc869bd540a0a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render pipeline following the score conventions for shaders and materials. <br /></td></tr>
<tr class="separator:a24838f6c2d71668a1cc869bd540a0a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada75ef58fe373211a06093b50051b6e0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; QShader, QShader &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#ada75ef58fe373211a06093b50051b6e0">makeShaders</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;v, QString vert, QString frag)</td></tr>
<tr class="memdesc:ada75ef58fe373211a06093b50051b6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pair of compiled vertex / fragment shaders from GLSL 4.5 sources.  <a href="namespacescore_1_1gfx.html#ada75ef58fe373211a06093b50051b6e0">More...</a><br /></td></tr>
<tr class="separator:ada75ef58fe373211a06093b50051b6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433eac87f8111d670824ff45923297fc"><td class="memItemLeft" align="right" valign="top">QShader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#a433eac87f8111d670824ff45923297fc">makeCompute</a> (const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;v, QString compt)</td></tr>
<tr class="memdesc:a433eac87f8111d670824ff45923297fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a compute shader.  <a href="namespacescore_1_1gfx.html#a433eac87f8111d670824ff45923297fc">More...</a><br /></td></tr>
<tr class="separator:a433eac87f8111d670824ff45923297fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bc42141b98c6699c7e5aee3674c38e"><td class="memItemLeft" align="right" valign="top"><a id="af3bc42141b98c6699c7e5aee3674c38e"></a>
QSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#af3bc42141b98c6699c7e5aee3674c38e">resizeTextureSize</a> (QSize img, int min, int max) noexcept</td></tr>
<tr class="memdesc:af3bc42141b98c6699c7e5aee3674c38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the size of a texture to fit within GPU limits. <br /></td></tr>
<tr class="separator:af3bc42141b98c6699c7e5aee3674c38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9462b53d25a8fe2f2a7de730a261d8"><td class="memItemLeft" align="right" valign="top"><a id="aae9462b53d25a8fe2f2a7de730a261d8"></a>
QImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#aae9462b53d25a8fe2f2a7de730a261d8">resizeTexture</a> (const QImage &amp;img, int min, int max) noexcept</td></tr>
<tr class="memdesc:aae9462b53d25a8fe2f2a7de730a261d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a texture to fit within GPU limits. <br /></td></tr>
<tr class="separator:aae9462b53d25a8fe2f2a7de730a261d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd667b8e0754c3ba35260d4e15e95bc0"><td class="memItemLeft" align="right" valign="top"><a id="acd667b8e0754c3ba35260d4e15e95bc0"></a>
QSizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescore_1_1gfx.html#acd667b8e0754c3ba35260d4e15e95bc0">computeScale</a> (<a class="el" href="namespacescore_1_1gfx.html#ac7b0a6847f2f616b12a8fe08a1229b58">score::gfx::ScaleMode</a> mode, QSizeF viewport, QSizeF texture)</td></tr>
<tr class="memdesc:acd667b8e0754c3ba35260d4e15e95bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comput the scale to apply to a texture so that it fits in a GL viewport. <br /></td></tr>
<tr class="separator:acd667b8e0754c3ba35260d4e15e95bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac6dcff8c5e43627a9801cd96b565e1"><td class="memItemLeft" align="right" valign="top"><a id="a9ac6dcff8c5e43627a9801cd96b565e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyMatrix</b> (const QMatrix4x4 &amp;mat, float *ptr) noexcept</td></tr>
<tr class="separator:a9ac6dcff8c5e43627a9801cd96b565e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d873668123906da344616f30f020f9"><td class="memItemLeft" align="right" valign="top"><a id="a63d873668123906da344616f30f020f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyMatrix</b> (const QMatrix3x3 &amp;mat, float *ptr) noexcept</td></tr>
<tr class="separator:a63d873668123906da344616f30f020f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a57170d1e694379b976b929a2b187558a"><td class="memItemLeft" align="right" valign="top"><a id="a57170d1e694379b976b929a2b187558a"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>frag</b></td></tr>
<tr class="separator:a57170d1e694379b976b929a2b187558a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2a7541026217601bd51343feafdac49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7541026217601bd51343feafdac49c">&#9670;&nbsp;</a></span>createRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscore_1_1gfx_1_1_texture_render_target.html">TextureRenderTarget</a> score::gfx::createRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QRhiTexture::Format&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSize&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QRhiTexture::Flags&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a render target from a texture format and size. </p>
<p>This function will also create a texture. </p>

</div>
</div>
<a id="a433eac87f8111d670824ff45923297fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433eac87f8111d670824ff45923297fc">&#9670;&nbsp;</a></span>makeCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QShader score::gfx::makeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>compt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a compute shader. </p>
<p>Note: this function will throw if the shader is invalid. </p>

</div>
</div>
<a id="ada75ef58fe373211a06093b50051b6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada75ef58fe373211a06093b50051b6e0">&#9670;&nbsp;</a></span>makeShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; QShader, QShader &gt; score::gfx::makeShaders </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structscore_1_1gfx_1_1_render_state.html">RenderState</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>vert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>frag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pair of compiled vertex / fragment shaders from GLSL 4.5 sources. </p>
<p>Note: this function will throw if a shader is invalid. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
